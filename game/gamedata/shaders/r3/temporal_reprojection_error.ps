#include "common.h"

// ----------------------
// temporal_reprojection.ps
// ----------------------

uniform Texture2D s_history;

uniform float4x4 m_tVP;

// samplers:
// s0 - smp_nofilter
// s1 - smp_rtlinear

// textures:
// t0 - s_image
// t1 - s_position
// t2 - s_history

// constants:
// cb0[2] - m_v2w[0]
// cb0[3] - m_v2w[1]
// cb0[4] - m_v2w[2]

// cb0[6] - m_tVP[0]
// cb0[7] - m_tVP[1]
// cb0[8] - m_tVP[2]
// cb0[9] - m_tVP[3]

// cb1[20] - pos_decompression_params
// cb1[21] - screen_res (pos_decompression_params2)

// cb2[0] - taa_jitter

float4 main(float2 tc : TEXCOORD0) : SV_Target
{
	// calc position scale
	// mul r0.y, cb1[21].z, cb1[21].y
	// mov r0.xz, l(1.000000,0,0,0)
	// mul r0.xy, r0.xyxx, cb1[20].xxxx
	
	float3 posScale;
		posScale.xy = float2(1, screen_res.z*screen_res.y) * pos_decompression_params.x;// r0.xy
		posScale.z = 0;//r0.z
	
	// calc original uv, without jitter
	// mad r1.xy, -cb2[0].xyxx, l(-0.500000, 0.500000, 0.000000, 0.000000), v0.xyxx
	float2 tcJitter = tc - taa_jitter.xy * 0.5;// r1.xy
	
	// sample_indexable(texture2d)(float,float,float,float) r2.xyz, r1.xyxx, t0.xyzw, s1
	float3 color = s_image.Sample(smp_rtlinear, tcJitter).xyz;// r2.xyz
	
	// calc pixel-area luminance
	// mad r3.xyzw, cb1[21].zwzw, l(0.000000, 1.000000, 0.000000, -1.000000), r1.xyxy
	// sample_indexable(texture2d)(float,float,float,float) r1.z, r3.xyxx, t0.xzyw, s1
	// sample_indexable(texture2d)(float,float,float,float) r1.w, r3.zwzz, t0.xzwy, s1
	// mad r3.xyzw, cb1[21].zwzw, l(1.000000, 0.000000, -1.000000, 0.000000), r1.xyxy
	// sample_indexable(texture2d)(float,float,float,float) r2.w, r3.xyxx, t0.xzwy, s1
	// sample_indexable(texture2d)(float,float,float,float) r3.x, r3.zwzz, t0.yxzw, s1
	
	float4 luma = float4(
		s_image.Sample(smp_rtlinear, tcJitter + screen_res.zw * int2( 0,  1)).y,// r1.z
		s_image.Sample(smp_rtlinear, tcJitter + screen_res.zw * int2( 0, -1)).y,// r1.w
		s_image.Sample(smp_rtlinear, tcJitter + screen_res.zw * int2( 1,  0)).y,// r2.w
		s_image.Sample(smp_rtlinear, tcJitter + screen_res.zw * int2(-1,  0)).y);// r3.x
	
	
	// calc pixel-area brightness
	// add r1.zw, -r1.zzzw, r2.yyyy
	// max r1.z, |r1.w|, |r1.z|
	// add r1.w, -r2.w, r2.y
	// max r1.z, |r1.w|, r1.z
	// add r1.w, r2.y, -r3.x
	// max r1.z, |r1.w|, r1.z
	// mul r1.z, r1.z, r1.z
	// mul r1.z, r1.z, r1.z
	// mul r1.z, r1.z, l(1000.000000)
	// min r1.z, r1.z, l(1.000000)
	
	// r1.zw = r2.yy - r1.zw;
	// r1.z = max(abs(r1.w), abs(r1.z));
	// r1.w = r2.y - r2.w;
	// r1.z = max(r1.z, abs(r1.w));
	// r1.w = r2.y - r3.x;
	// r1.z = max(r1.z, abs(r1.w));
	// r1.z *= r1.z;
	// r1.z = min(r1.z * r1.z * 1000, 1);

	float localBright = max(abs(color.y - luma.x), abs(color.y - luma.y));
		localBright = max(localBright, abs(color.y - luma.z));
		localBright = max(localBright, abs(color.y - luma.w));
		localBright *= localBright;
		localBright = min(localBright*localBright*1000, 1);// r1.z
	
	
	// ----------------------
	// current state:
	// r0.xyz 	= posScale
	// r1.xy 	= tcJitter
	// r1.z 	= localBright
	// r2.xyz 	= color
	// ----------------------
	
	// calc hud? mask
	// sample_l_indexable(texture2d)(float,float,float,float) r1.x, r1.xyxx, t1.wxyz, s0, l(0.000000)
	// ftoi r1.x, r1.x
	// imax r1.x, -r1.x, r1.x
	// and r1.x, r1.x, l(255)
	// utof r1.x, r1.x
	// mul r1.y, r1.x, l(0.003922)
	// ne r1.y, l(0.000000, 0.000000, 0.000000, 0.000000), r1.y
	// mad r1.x, r1.x, l(0.007843), l(-1.000000)
	// lt r1.x, r1.x, l(0.000000)
	// and r1.x, r1.y, r1.x
	// and r1.y, r1.x, l(1)
	
	// float packedBuffer1f = s_position.SampleLevel(smp_nofilter, tcJitter, 0).w;// sample_l & ftoi
	
	// int packedBuffer1i = packedBuffer1f;
	// packedBuffer1i = -packedBuffer1i > packedBuffer1i ? -packedBuffer1i : packedBuffer1i;
	
	// packedBuffer1f = packedBuffer1i & 255;// r1.x
	// float packedBuffer1f2 = packedBuffer1f * 0.003922;// r1.y
	
	// packedBuffer1i = packedBuffer1f2 != 0;// r1.y
	// packedBuffer1f = packedBuffer1f * 0.007843 - 1.0;
	// packedBuffer1i &= (packedBuffer1f < 0);// r1.y
	
	float packedBuffer1 = s_position.SampleLevel(smp_nofilter, tcJitter, 0).w;
	
	int hud = (int)abs(packedBuffer1) & 255;
	hud = packedBuffer1 != 0 && hud < 127.5;// r1.y
	
	// sample_l_indexable(texture2d)(float,float,float,float) r1.w, v0.xyxx, t1.xywz, s0, l(0.000000)
	float depth = s_position.SampleLevel(smp_nofilter, tc, 0).z;// r1.w

	
	// ge r2.w, r1.w, l(0.010000)
	// movc r1.w, r2.w, r1.w, l(1000.000000)
	
	// r2.w = r1.w >= 0.01;
	// r1.w = r2.w ? r1.w : 1000;
	
	depth = depth >= 0.01 ? depth : 1000;
	
	// calc tangent space position
	// mad r3.xy, v0.xyxx, l(2.000000, -2.000000, 0.000000, 0.000000), l(-1.000000, 1.000000, 0.000000, 0.000000)
	// mul r3.xy, r0.xyxx, r3.xyxx
	// mov r3.zw, l(0,0,1.000000,1.000000)
	// mul r3.xyz, r1.wwww, r3.xyzx
	
	// r3.xy = v0.xy * int2( 2, -2) + int2(-1,  1);// uv to [-1.. 1]
	// r3.xy = r0.xy * r3.xy;// make quad
	// r3.zw = 1.0;
	// r3.xyz = r3.xyz * r1.w;
	
	float4 position = float4(tc * 2 - 1, 1, 1);
	position *= float4(depth * posScale.x, depth * -posScale.y, depth, 1);// r3.xyzw
	
	
	// ----------------------
	// current state:
	// r0.xyz 	= posScale
	// r1.y		= hud
	// r1.z		= localBright
	// r1.w 	= depth
	// r2.xyz	= color
	// r3.xyzw	= position
	// ----------------------
	
	// to world space
	// dp4 r4.x, cb0[2].xyzw, r3.xyzw
	// dp4 r4.y, cb0[3].xyzw, r3.xyzw
	// dp4 r4.z, cb0[4].xyzw, r3.xyzw
	// mov r4.w, l(1.000000)
	
	// to previous non-linear tangent space
	// dp4 r0.x, cb0[6].xyzw, r4.xyzw
	// dp4 r0.y, cb0[7].xyzw, r4.xyzw
	// dp4 r1.w, cb0[9].xyzw, r4.xyzw
	
	// approximatrly next uv for the previous frame
	// div r3.xyzw, r0.xxxy, r1.wwww
	// mad r3.xyzw, r3.xyzw, l(0.500000, 0.500000, 0.500000, -0.500000), l(0.500000, 0.500000, 0.500000, 0.500000)

	// r4.xyz = mul(cb0[2], r3);
	// r4.w = 1;
	// float4(r0.x, r0.y, 0, r1.w) = mul(cb0[6], r4);
	// r3.zw = r0.xy / r1.w;
	// r3.zw = r3.zw * float2(0.5, -0.5) + 0.5;
	
	float4 positionWorld;
	positionWorld.xyz = mul(m_v2w, position);
	positionWorld.w = 1;
	
	float4 positionProjNext = mul(m_tVP, positionWorld);
	positionProjNext.xy /= positionProjNext.w;
	positionProjNext.xy = positionProjNext.xy * float2(0.5, -0.5) + 0.5;// r3.zw
	
	
	// movc r3.xyzw, r1.yyyy, v0.xxxy, r3.xyzw
	positionProjNext.xy = hud ? tc : positionProjNext.xy;// r3.zw
	
	
	// ge r0.xy, r3.zwzz, l(0.000000, 0.000000, 0.000000, 0.000000)
	// ge r4.xy, l(1.000000, 1.000000, 0.000000, 0.000000), r3.zwzz
	// and r0.xy, r0.xyxx, r4.xyxx
	// and r0.x, r0.y, r0.x
	
	// r0.xy = r3.zw >= 0.0;
	// r4.xy = 1.0 >= r3.zw;
	// r0.xy = r0.xy & r4.xy;
	// r0.x = r0.y & r0.x;
	
	bool isScreenSpace = all(positionProjNext.xy >= 0.0 && positionProjNext.xy <= 1.0);// r0.x
	
	// tc offset like a SM3?
	// mad r3.xyzw, r3.xyzw, cb1[21].xxxy, l(0.500000, 0.500000, 0.500000, 0.500000)
	// round_ni r4.xy, r3.zwzz
	// div r4.xy, r4.xyxx, cb1[21].xyxx
	// mad r4.xy, -cb1[21].zwzz, l(0.500000, 0.500000, 0.000000, 0.000000), r4.xyxx
	
	float2 pos2dNext = positionProjNext.xy * screen_res.xy + 0.5;
	float2 tcNext = screen_res.zw * (floor(pos2dNext) - 0.5);// r4.xy
	
	//-------------- sample history area
	float4 historyArea[16];
	float4 historyBias = float4(-1, 0, 1, 2);
	
	// mov r5.xyz, -cb1[21].zwzz
	// add r4.zw, r4.xxxy, r5.xxxy
	// sample_indexable(texture2d)(float,float,float,float) r6.xyzw, r4.zwzz, t2.xyzw, s1
	// (-1, -1)
	
	// mov r0.w, -cb1[21].w
	// add r0.yz, r0.zzwz, r4.xxyx
	// sample_indexable(texture2d)(float,float,float,float) r7.xyzw, r0.yzyy, t2.xyzw, s1
	// ( 0, -1)
	
	// mad r0.yz, cb1[21].zzwz, l(0.000000, 1.000000, -1.000000, 0.000000), r4.xxyx
	// sample_indexable(texture2d)(float,float,float,float) r8.xyzw, r0.yzyy, t2.xyzw, s1
	// ( 1, -1)
	
	// mul r0.z, cb1[21].z, l(2.000000)
	// mad r4.zw, cb1[21].zzzw, l(0.000000, 0.000000, 2.000000, -1.000000), r4.xxxy
	// sample_indexable(texture2d)(float,float,float,float) r9.xyzw, r4.zwzz, t2.xyzw, s1
	// ( 2, -1)
	
	historyArea[ 0] = s_history.Sample(smp_rtlinear, tcNext + screen_res.zw * historyBias.xx);// r6
	historyArea[ 1] = s_history.Sample(smp_rtlinear, tcNext + screen_res.zw * historyBias.yx);// r7
	historyArea[ 2] = s_history.Sample(smp_rtlinear, tcNext + screen_res.zw * historyBias.zx);// r8
	historyArea[ 3] = s_history.Sample(smp_rtlinear, tcNext + screen_res.zw * historyBias.wx);// r9
	
	// mov r5.w, l(0)
	// add r4.zw, r4.xxxy, r5.zzzw
	// sample_indexable(texture2d)(float,float,float,float) r5.xyzw, r4.zwzz, t2.xyzw, s1
	// (-1,  0)
	
	// sample_indexable(texture2d)(float,float,float,float) r10.xyzw, r4.xyxx, t2.xyzw, s1
	// ( 0,  0)
	
	// mov r11.xw, cb1[21].zzzw
	// mov r11.yz, l(0,0,0,0)
	// add r11.xyzw, r4.xyxy, r11.xyzw
	// sample_indexable(texture2d)(float,float,float,float) r12.xyzw, r11.xyxx, t2.xyzw, s1
	// ( 1,  0)
	
	// mov r0.w, l(0)
	// add r0.yz, r0.zzwz, r4.xxyx
	// sample_indexable(texture2d)(float,float,float,float) r13.xyzw, r0.yzyy, t2.xyzw, s1
	// ( 2, 0)
	
	historyArea[ 4] = s_history.Sample(smp_rtlinear, tcNext + screen_res.zw * historyBias.xy);// r5
	historyArea[ 5] = s_history.Sample(smp_rtlinear, tcNext + screen_res.zw * historyBias.yy);// r10
	historyArea[ 6] = s_history.Sample(smp_rtlinear, tcNext + screen_res.zw * historyBias.zy);// r12
	historyArea[ 7] = s_history.Sample(smp_rtlinear, tcNext + screen_res.zw * historyBias.wy);// r13
	
	// mad r14.xyzw, cb1[21].zwzw, l(-1.000000, 1.000000, 2.000000, 1.000000), r4.xyxy
	// sample_indexable(texture2d)(float,float,float,float) r15.xyzw, r14.xyxx, t2.xyzw, s1
	// (-1, 1)
	
	// sample_indexable(texture2d)(float,float,float,float) r11.xyzw, r11.zwzz, t2.xyzw, s1
	// ( 0, 1)
	
	// add r0.yz, r4.xxyx, cb1[21].zzwz
	// sample_indexable(texture2d)(float,float,float,float) r16.xyzw, r0.yzyy, t2.xyzw, s1
	// ( 1, 1)
	
	// sample_indexable(texture2d)(float,float,float,float) r14.xyzw, r14.zwzz, t2.xyzw, s1
	// ( 2, 1)
	
	historyArea[ 8] = s_history.Sample(smp_rtlinear, tcNext + screen_res.zw * historyBias.xz);// r15
	historyArea[ 9] = s_history.Sample(smp_rtlinear, tcNext + screen_res.zw * historyBias.yz);// r11
	historyArea[10] = s_history.Sample(smp_rtlinear, tcNext + screen_res.zw * historyBias.zz);// r16
	historyArea[11] = s_history.Sample(smp_rtlinear, tcNext + screen_res.zw * historyBias.wz);// r14
	
	// mul r0.w, cb1[21].w, l(2.000000)
	// mad r4.zw, cb1[21].zzzw, l(0.000000, 0.000000, -1.000000, 2.000000), r4.xxxy
	// sample_indexable(texture2d)(float,float,float,float) r17.xyzw, r4.zwzz, t2.xyzw, s1
	// (-1, 2)
	
	// mov r0.z, l(0)
	// add r0.yz, r0.zzwz, r4.xxyx
	// sample_indexable(texture2d)(float,float,float,float) r18.xyzw, r0.yzyy, t2.xyzw, s1
	// ( 0, 2)
	
	// mad r0.yz, cb1[21].zzwz, l(0.000000, 1.000000, 2.000000, 0.000000), r4.xxyx
	// sample_indexable(texture2d)(float,float,float,float) r19.xyzw, r0.yzyy, t2.xyzw, s1
	// ( 1, 2)
	
	// mad r0.yz, cb1[21].zzwz, l(0.000000, 2.000000, 2.000000, 0.000000), r4.xxyx
	// sample_indexable(texture2d)(float,float,float,float) r4.xyzw, r0.yzyy, t2.xyzw, s1
	// ( 2, 2)
	
	historyArea[12] = s_history.Sample(smp_rtlinear, tcNext + screen_res.zw * historyBias.xw);// r17
	historyArea[13] = s_history.Sample(smp_rtlinear, tcNext + screen_res.zw * historyBias.yw);// r18
	historyArea[14] = s_history.Sample(smp_rtlinear, tcNext + screen_res.zw * historyBias.zw);// r19
	historyArea[15] = s_history.Sample(smp_rtlinear, tcNext + screen_res.zw * historyBias.ww);// r4
	
	//  r6 = historyArea[ 0]
	//  r7 = historyArea[ 1]
	//  r8 = historyArea[ 2]
	//  r9 = historyArea[ 3]
	//  r5 = historyArea[ 4]
	// r10 = historyArea[ 5]
	// r12 = historyArea[ 6]
	// r13 = historyArea[ 7]
	// r15 = historyArea[ 8]
	// r11 = historyArea[ 9]
	// r16 = historyArea[10]
	// r14 = historyArea[11]
	// r17 = historyArea[12]
	// r18 = historyArea[13]
	// r19 = historyArea[14]
	//  r4 = historyArea[15]
	
	//-------------- sample area
	float3 limitsArea[4];
	float3 limitsBias = float3(-1, 0, 1);
	
	// mad r20.xyzw, cb1[21].zwzw, l(-1.000000, 0.000000, 1.000000, 0.000000), v0.xyxy
	// sample_indexable(texture2d)(float,float,float,float) r0.yzw, r20.xyxx, t0.wxyz, s1
	// sample_indexable(texture2d)(float,float,float,float) r20.xyz, r20.zwzz, t0.xyzw, s1
	// mad r21.xyzw, cb1[21].zwzw, l(0.000000, -1.000000, 0.000000, 1.000000), v0.xyxy
	// sample_indexable(texture2d)(float,float,float,float) r22.xyz, r21.xyxx, t0.xyzw, s1
	// sample_indexable(texture2d)(float,float,float,float) r21.xyz, r21.zwzz, t0.xyzw, s1
	
	limitsArea[0] = s_image.Sample(smp_rtlinear, tcNext + screen_res.zw * limitsBias.xy).xyz;// r0.yzw
	limitsArea[1] = s_image.Sample(smp_rtlinear, tcNext + screen_res.zw * limitsBias.zy).xyz;//   r20
	limitsArea[2] = s_image.Sample(smp_rtlinear, tcNext + screen_res.zw * limitsBias.yx).xyz;//   r22
	limitsArea[3] = s_image.Sample(smp_rtlinear, tcNext + screen_res.zw * limitsBias.yz).xyz;//   r21
	
	// r0.yzw = limitsArea[0]
	//   r20  = limitsArea[1]
	//   r22  = limitsArea[2]
	//   r21  = limitsArea[3]
	
	// if_nz r0.x
	
	// if(isScreenSpace && !hud)
	if(isScreenSpace)
	{
		// frc r3.xyzw, r3.xyzw
		float4 fracQuadNext = frac(pos2dNext.xxxy);// r3

		//---------- some kind of filter s_history..
		//-----

		float4 t0, t1, t2, t3, t4, t5, t6;
		
		t1 = fracQuadNext;
		t3 = historyArea[1];
		t4 = historyArea[0];
		t5 = historyArea[4];
		t6 = historyArea[2];
		
		// add r23.xyzw, r3.xyzw, l(-1.000000, -2.000000, 1.000000, -1.000000)
		// mul r3.xy, -r3.zwzz, r23.xwxx
		// mul r3.xy, r3.xyxx, l(-0.500000, -0.500000, 0.000000, 0.000000)
		// mul r0.x, r23.y, r3.x
		// mul r0.x, r0.x, l(-0.333333)
		// mul r1.w, r23.x, r23.z
		// mul r1.w, r23.y, r1.w
		// mul r1.w, r1.w, l(0.500000)
		
		t2 = t1 + int4(-1, -2,  1, -1);
		t1.xy = t1.zw * -t2.xw;
		t1.xy = t1.xy * -0.5;
		t0.x = t2.y * t1.x;
		t0.x = t0.x * -0.333333;
		t0.y = t2.x * t2.z;
		t0.y = t0.y * t2.y;
		t0.y = t0.y * 0.5;
		
		// mul r7.xyzw, r1.wwww, r7.xyzw
		// mad r6.xyzw, r6.xyzw, r0.xxxx, r7.xyzw
		// mul r2.w, r3.z, r23.z
		// mul r3.xz, r23.yyxy, r2.wwww
		// mul r3.xz, r3.xxzx, l(-0.500000, 0.000000, 0.166667, 0.000000)
		// mad r6.xyzw, r8.xyzw, r3.xxxx, r6.xyzw
		// mad r6.xyzw, r9.xyzw, r3.zzzz, r6.xyzw
		// mul r7.xyzw, r1.wwww, r10.xyzw
		
		t3 = t3 * t0.y;
		t4 = t4 * t0.x + t3;
		t0.z = t1.z * t2.z;
		t1.xz = t2.yx * t0.z;
		t1.xz = t1.xz * float2(-0.500000, 0.166667);
		t4 = t4 + t6 * t1;
		t4 = t4 + historyArea[3] * t1.z;
		t3 = historyArea[5] * t0.y;
		
		// mad r5.xyzw, r5.xyzw, r0.xxxx, r7.xyzw
		// mad r5.xyzw, r12.xyzw, r3.xxxx, r5.xyzw
		// mad r5.xyzw, r13.xyzw, r3.zzzz, r5.xyzw
		// mul r7.xyzw, r1.wwww, r11.xyzw
		// mad r7.xyzw, r15.xyzw, r0.xxxx, r7.xyzw
		// mad r7.xyzw, r16.xyzw, r3.xxxx, r7.xyzw
		// mad r7.xyzw, r14.xyzw, r3.zzzz, r7.xyzw
		// mul r8.xyzw, r1.wwww, r18.xyzw
		
		t5 = t3 + t5 * t0.x;
		t5 = t5 + historyArea[6] * t1.x;
		t5 = t5 + historyArea[7] * t1.x;
		t3 = historyArea[9] * t0.y;
		t3 = t3 + historyArea[8] * t0.x;
		t3 = t3 + historyArea[10] * t1.x;
		t3 = t3 + historyArea[11] * t1.z;
		t6 = historyArea[13] * t0.y;
		
		// mad r8.xyzw, r17.xyzw, r0.xxxx, r8.xyzw
		// mad r8.xyzw, r19.xyzw, r3.xxxx, r8.xyzw
		// mad r4.xyzw, r4.xyzw, r3.zzzz, r8.xyzw
		// add r3.xz, r3.wwww, l(-2.000000, 0.000000, 1.000000, 0.000000)
		// mul r0.x, r3.x, r3.y
		// mul r0.x, r0.x, l(-0.333333)
		// mul r1.w, r23.w, r3.z
		// mul r1.w, r3.x, r1.w
		
		t6 = t6 + historyArea[12] * t0.x;
		t6 = t6 + historyArea[14] * t1.x;
		t6 = historyArea[15] * t1.z + t6;
		t1.xz = t1.xz + int2(-2,  1);
		t0.x = t1.x * t1.y;
		t0.x = t0.x * -0.333333;
		t0.y = t2.w * t1.z;
		t0.y = t1.x * t0.y;
		
		// mul r1.w, r1.w, l(0.500000)
		// mul r5.xyzw, r1.wwww, r5.xyzw
		// mad r5.xyzw, r6.xyzw, r0.xxxx, r5.xyzw
		// mul r0.x, r3.w, r3.z
		// mul r1.w, r3.x, r0.x
		// mul r1.w, r1.w, l(-0.500000)
		// mad r3.xyzw, r7.xyzw, r1.wwww, r5.xyzw
		// mul r0.x, r23.w, r0.x
		
		t0.y = t0.y * 0.5;
		t5 = t5 * t0.y;
		t5 = t5 + t4 * t0.x;
		t0.x = t1.w * t1.z;
		t0.y = t1.x * t0.x;
		t0.y = t0.y * -0.5;
		t1 = t3 * t0.y + t5;
		t0.x = t0.x * t2.w;
		
		// mul r0.x, r0.x, l(0.166667)
		// mad r3.xyzw, r4.xyzw, r0.xxxx, r3.xyzw
		t0.x = t0.x * 0.166667;
		t1 = t1 + t6 * t0.x;
		
		// mul r0.x, r3.w, l(255.000000)
		// ftou r0.x, r0.x
		t0.x = t1.w * 255;

		//-----------------------
		// pack like a "BBBB BBBH", B - brightness, H - hud
		// float localBrightAndHud = 0.003922 * (localBright * 127 + hud * 128);
		//-----------------------
		
		// ubfe r1.w, l(1), l(7), r0.x
		// some mask?
		// r1.w = (r1.w & 0x80) / 0x80;
		
		uint filteredMask = (uint(t0.x) & 0x80) / 0x80;
		
		//-----
		// t0 = float4(r0.x, r1.w, r2.w, 0)
		// t1 = r3
		// t2 = r23
		// t3 = r7
		// t4 = r6
		// t5 = r5
		// t6 = r8, last r4
		//----
		
		// a hud mask
		// ieq r2.w, r1.x, l(0)
		// hud == 0
		
		// ine r1.w, r1.w, l(0)
		// and r1.w, r1.w, r2.w
		
		// r2.w = r1.x == 0;
		// r1.w = r1.w != 0;
		// r1.w = r1.w & r2.w;
		
		// !hud && filteredMask;
		
		bool isInvisibleByHud = !hud && filteredMask;
		
		// if_z r1.w
		// if(!r1.w)
		if(!isInvisibleByHud)
		{
			// add r1.w, -r1.z, l(1.000000)
			// and r0.x, r0.x, l(127)
			// utof r0.x, r0.x
			// mad r0.x, -r0.x, l(0.007874), l(1.000000)
			
			float localDark = 1 - localBright;
			t0.x = uint(t0.x) & 127;
			t0.x = (float)t0.x;
			t0.x = -t0.x * 0.007874 + 1;
			
			//-----
			// compute neighbourhood clamping
			
			// min r4.xyz, r0.yzwy, r2.xyzx
			// max r0.yzw, r0.yyzw, r2.xxyz
			// min r4.xyz, r20.xyzx, r4.xyzx
			// max r0.yzw, r20.xxyz, r0.yyzw
			// min r4.xyz, r22.xyzx, r4.xyzx
			// max r0.yzw, r22.xxyz, r0.yyzw
			// min r4.xyz, r21.xyzx, r4.xyzx
			// max r0.yzw, r21.xxyz, r0.yyzw
			
			// r4.xyz = min(r0.yzw, r2.xyz);
			// r0.yzw = max(r0.yzw, r2.xyz);
			// r4.xyz = min(r20.xyz, r4.xyz);
			// r0.yzw = max(r20.xyz, r0.yzw);
			// r4.xyz = min(r22.xyz, r4.xyz);
			// r0.yzw = max(r22.xyz, r0.yzw);
			// r4.xyz = min(r21.xyz, r4.xyz);
			// r0.yzw = max(r21.xyz, r0.yzw);
			
			float3 neighMin = color, 
				neighMax = color;
			
			neighMin = min(limitsArea[0], neighMin);
			neighMin = min(limitsArea[1], neighMin);
			neighMin = min(limitsArea[2], neighMin);
			neighMin = min(limitsArea[3], neighMin);// r4.xyz
			
			neighMax = max(limitsArea[0], neighMax);
			neighMax = max(limitsArea[1], neighMax);
			neighMax = max(limitsArea[2], neighMax);
			neighMax = max(limitsArea[3], neighMax);// r0.yzw
			
			// some limits..?
			
			// add r5.xyz, r4.xyzx, r0.yzwy
			// add r0.yzw, -r4.xxyz, r0.yyzw
			// mul r0.yzw, r0.yyzw, l(0.000000, 0.500000, 0.500000, 0.500000)
			// mad r4.xyz, -r5.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), r3.xyzx
			// div r0.yzw, r4.xxyz, r0.yyzw
			
			float3 neightSum = neighMin + neighMax;
			float3 neightSub = neighMax - neighMin;
			
			float3 neighFactor;
			
			neighMin = neightSub * 0.5;
			neighMax = t1.xyz - neightSum * 0.5;
			
			neighFactor = neighMax / neighMin;// r0.yzw
			
			// max r0.z, |r0.w|, |r0.z|
			// max r0.y, r0.z, |r0.y|
			
			// (yzw to xyz)
			
			neighFactor.y = max(abs(neighFactor.z), abs(neighFactor.y));// r0.z
			neighFactor.x = max(neighFactor.y, abs(neighFactor.x));// r0.y
			
			// mask?
			// add r0.x, -r0.x, r1.w
			// lt r0.x, |r0.x|, l(0.010000)
			// or r0.x, r0.x, r1.x
			
			bool mask = uint(abs(localDark - t0.x) < 0.01) | hud;// r0.x
			
			// coeffs..
			
			// movc r0.xz, r0.xxxx, l(1.500000,0,0.962500,0), l(3.000000,0,0.937500,0)
			float2 powerVector = mask ? float2(1.5000, 0.9625) : float2(3.0000, 0.9375);// r0.xz

			//-----
			// mix
			
			// ge r0.x, r0.x, r0.y
			// add r3.xyz, -r2.xyzx, r3.xyzx
			// mad r0.yzw, r0.zzzz, r3.xxyz, r2.xxyz
			// movc o0.xyz, r0.xxxx, r0.yzwy, r2.xyzx
			
			// ?
			// mask = powerVector.x >= neighFactor.x;// r0.x
			
			// r3.xyz = r3.xyz - r2.xyz;
			// r0.yzw = r3.xyz * r0.z + r2.xyz;
			// float3 history = (t1.xyz - color) * powerVector.y + color;
			
			// color = r0.x ? r0.yzw : r2.xyz;
			// color = mask ? history : color;
			
			color = mask;
		}
		// else 
			// mov o0.xyz, r2.xyzx
		// endif 
	}
	
	// else
	  // mov o0.xyz, r2.xyzx
	// endif 
	
	
	//------------ pack color & hud & brightness
	
	// pack like a "BBBB BBBH", B - brightness, H - hud
	// mul r0.x, r1.z, l(127.000000)
	// ftou r0.x, r0.x
	// imad r0.x, r1.y, l(128), r0.x
	// utof r0.x, r0.x
	// mul o0.w, r0.x, l(0.003922)
	// ret 
	
	float localBrightAndHud = 0.003922 * (localBright * 127 + hud * 128);
	
	return float4(color, localBrightAndHud);
}