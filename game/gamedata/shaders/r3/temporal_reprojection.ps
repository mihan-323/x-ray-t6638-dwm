#include "common.h"

uniform Texture2D s_history;
// uniform Texture2D<float2> s_motion;

uniform float4x4 m_tVP;

namespace AAHelper
{
	struct SCENE
	{
		float3 	color;	// 24 bit
		float 	edge;	// 7 bit
		float 	plane;	// 
		uint 	mask;	// 1 bit
	};

	float4	buffer	(float2	tc);
	float4	pack	(SCENE	scene);
	SCENE	unpack	(float4	packed);
	void	lerp	(inout SCENE scene, SCENE history, float f);
	SCENE	make	(float3	color, float edge, uint mask);
	SCENE	load	(float2	tc);
	SCENE	history	(float2	tc);
	float3	color	(float2	tc);
	float	edge	(float2	tc);
	uint	mask	(float2	tc);

	namespace LagrangeSampler
	{
		static float2 c_onePixel = screen_res.zw;
		static float2 c_twoPixels = 2.0 * screen_res.zw;

		static float c_x0 = -1.0;
		static float c_x1 =  0.0;
		static float c_x2 =  1.0;
		static float c_x3 =  2.0;

		float4 FilterCubic(float4 A, float4 B, float4 C, float4 D, float t)
		{
			return A * ((t - c_x1) / (c_x0 - c_x1) * 
					    (t - c_x2) / (c_x0 - c_x2) *
					    (t - c_x3) / (c_x0 - c_x3))

				 + B * ((t - c_x0) / (c_x1 - c_x0) * 
					    (t - c_x2) / (c_x1 - c_x2) *
					    (t - c_x3) / (c_x1 - c_x3))

				 + C * ((t - c_x0) / (c_x2 - c_x0) * 
					    (t - c_x1) / (c_x2 - c_x1) *
					    (t - c_x3) / (c_x2 - c_x3))

				 + D * ((t - c_x0) / (c_x3 - c_x0) * 
					    (t - c_x1) / (c_x3 - c_x1) *
					    (t - c_x2) / (c_x3 - c_x2));
		}

		float4 SampleBicubic(Texture2D iChannel1, float2 P)
		{
			float2 pixel = P * screen_res.xy + 0.5;
			
			float2 fract = frac(pixel);
			pixel = floor(pixel) / screen_res.xy - float2(c_onePixel/2.0);
			
			float4 C00 = iChannel1.Sample(smp_rtlinear, pixel + float2(-c_onePixel.x ,-c_onePixel.y));
			float4 C10 = iChannel1.Sample(smp_rtlinear, pixel + float2( 0.0          ,-c_onePixel.y));
			float4 C20 = iChannel1.Sample(smp_rtlinear, pixel + float2( c_onePixel.x ,-c_onePixel.y));
			float4 C30 = iChannel1.Sample(smp_rtlinear, pixel + float2( c_twoPixels.x,-c_onePixel.y));
			
			float4 C01 = iChannel1.Sample(smp_rtlinear, pixel + float2(-c_onePixel.x , 0.0));
			float4 C11 = iChannel1.Sample(smp_rtlinear, pixel + float2( 0.0          , 0.0));
			float4 C21 = iChannel1.Sample(smp_rtlinear, pixel + float2( c_onePixel.x , 0.0));
			float4 C31 = iChannel1.Sample(smp_rtlinear, pixel + float2( c_twoPixels.x, 0.0));    
			
			float4 C02 = iChannel1.Sample(smp_rtlinear, pixel + float2(-c_onePixel.x , c_onePixel.y));
			float4 C12 = iChannel1.Sample(smp_rtlinear, pixel + float2( 0.0          , c_onePixel.y));
			float4 C22 = iChannel1.Sample(smp_rtlinear, pixel + float2( c_onePixel.x , c_onePixel.y));
			float4 C32 = iChannel1.Sample(smp_rtlinear, pixel + float2( c_twoPixels.x, c_onePixel.y));    
			
			float4 C03 = iChannel1.Sample(smp_rtlinear, pixel + float2(-c_onePixel.x , c_twoPixels.y));
			float4 C13 = iChannel1.Sample(smp_rtlinear, pixel + float2( 0.0          , c_twoPixels.y));
			float4 C23 = iChannel1.Sample(smp_rtlinear, pixel + float2( c_onePixel.x , c_twoPixels.y));
			float4 C33 = iChannel1.Sample(smp_rtlinear, pixel + float2( c_twoPixels.x, c_twoPixels.y));    
			
			float4 CP0X = FilterCubic(C00, C10, C20, C30, fract.x);
			float4 CP1X = FilterCubic(C01, C11, C21, C31, fract.x);
			float4 CP2X = FilterCubic(C02, C12, C22, C32, fract.x);
			float4 CP3X = FilterCubic(C03, C13, C23, C33, fract.x);
			
			return FilterCubic(CP0X, CP1X, CP2X, CP3X, fract.y);
		}
	}

	float4 buffer(float2 tc)
	{
		return LagrangeSampler::SampleBicubic(s_history, tc);
	}

	float4 pack(SCENE scene)
	{
		return float4(scene.color, float((uint(scene.edge * 0x7F) & 0x7F) | 
										 (scene.mask << 7)) / 0xFF);
	}

	SCENE unpack(float4 packed)
	{
		uint a = packed.w * 0xFF;

		SCENE scene = make(packed.xyz, float(a & 0x7F) / 0x7F, (a & 0x80) / 0x80);

		return scene;
	}

	SCENE make(float3 color, float edge, uint mask)
	{
		SCENE scene = {color, edge, 1 - edge, mask};
		return scene;
	}

	SCENE load(float2 tc)
	{
		SCENE scene = make(color(tc), edge(tc), mask(tc));
		return scene;
	}

	SCENE history(float2 tc)
	{
		SCENE scene = unpack(buffer(tc));
		return scene;
	}

	float3 color(float2 tc)
	{
		return s_image.Sample(smp_rtlinear, tc).xyz;
	}

	float edge(float2 tc)
	{
		float luma			= color(tc).y;
		float luma_down 	= color(tc + screen_res.zw * int2( 0,  1)).y;
		float luma_up 		= color(tc + screen_res.zw * int2( 0, -1)).y;
		float luma_right 	= color(tc + screen_res.zw * int2( 1,  0)).y;
		float luma_left 	= color(tc + screen_res.zw * int2(-1,  0)).y;

		float edge = 	 abs(luma - luma_down);
		edge = max(edge, abs(luma - luma_up));
		edge = max(edge, abs(luma - luma_right));
		edge = max(edge, abs(luma - luma_left));

		edge = saturate(edge * edge * edge * edge * 1000);

		return edge;
	}

	uint mask(float2 tc)
	{
		return G_BUFFER::load_hud_mask(tc);
	}
}

void antialiasing(float2 tc, inout AAHelper::SCENE scene)
{
	float3 position = G_BUFFER::load_position_wsky(tc).xyz;

	float3 position_w = mul(m_v2w, float4(position, 1));

	float4 proj_next = mul(m_tVP, float4(position_w, 1));

	float2 tc_next = proj_next.xy / proj_next.ww * float2(0.5, -0.5) + 0.5;

	if(scene.mask)
		tc_next = tc;

	if(!is_in_quad(tc_next))
		return;

	AAHelper::SCENE history = AAHelper::history(tc_next);

	if(!scene.mask && history.mask)
		return;

	float3 limits[2];

	for(int i = -1; i <= 1; ++i)
	{
		for(int j = -1; j <= 1; ++j)
		{
			float3 neighbourhood = AAHelper::color(tc + float2(i, j) * screen_res.zw);

			limits[0] = min(scene.color, neighbourhood);
			limits[1] = max(scene.color, neighbourhood);
		}
	}

	float3 center  = 0.5 * (limits[1] + limits[0]);
	float3 extents = 0.5 * (limits[1] - limits[0]);

	float3 offset = history.color - center;
	float3 repeat = abs(offset / extents);

	float repeat_max = max(repeat.x, max(repeat.y, repeat.z));

	int depth_t = abs(scene.plane - history.plane) < 0.01;
	int hud_depth_t = scene.mask | depth_t;

	if(repeat_max <= 6 * (2 - hud_depth_t))
		scene.color = lerp(scene.color, history.color, 0.025 * (37.5 + hud_depth_t));
}

float4 main(float2 tc : TEXCOORD0) : SV_Target
{
	AAHelper::SCENE scene = AAHelper::load(tc - taa_offset_curr());

	antialiasing(tc, scene);

	return AAHelper::pack(scene);
}